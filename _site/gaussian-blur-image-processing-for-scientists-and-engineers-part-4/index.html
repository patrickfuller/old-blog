<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Gaussian Blur - Image processing for scientists and engineers, Part 4</title>
        <meta name="viewport" content="width=device-width">

        <!-- CSS - font, bootstrap, syntax, custom -->
        <link href='http://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="/css/bootstrap.css">
        <link rel="stylesheet" href="/css/font-awesome.min.css">
        <link rel="stylesheet" href="/css/syntax.css">
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">patrick fuller's blog</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Gaussian Blur - Image processing for scientists and engineers, Part 4</h2>
<p class="meta">25 Nov 2012</p>

<div class="post">
<p>Okay, so <a href="/convolution-an-introduction-to-image-processing-for-scientists-and-engineers/">we&#39;ve worked</a>
with pixels and their immediate neighbors, but what about the non-immediate
neighbors? Easily enough, we can include them by increasing our kernel size.
The previous 3x3 kernels cover immediate neighbors, 5x5 kernels go two steps
away, 7x7 is three steps, and so on. Cool, let&#39;s do something with this.</p>

<p>What if, rather than weighting all neighbors equally, we weight them based off
of their distance to the center pixel? Neighbors close to the center will have a
greater weight, and more distant neighbors will be weighted less. We could make
our own kernel and randomly fill in numbers that do this, but that wouldn&#39;t allow
mathematicians to write one of their favorite equations:</p>

<p><code>\(g(u,v) = \frac{1}{2\pi\sigma^2}e^{-\frac{u^2+v^2}{2\sigma^2}}\)</code></p>

<p>This is a two-dimensional version of the Gaussian function.Â Will it produce
dramatically different results than randomly picking numbers? Nah, not really.
But it&#39;s a standard, so let&#39;s use it.</p>

<p>All that really matters here is the general shape. It peaks in the center and
decays as you move away. You can control how quickly it decays by varying the
<code>\(\sigma\)</code> parameter. Bigger sigma, slower decay. Let&#39;s generate a 21x21 matrix of values from this function and use it as our kernel in convolution.</p>

<p>In our previous notation, this looks like a total mess:</p>

<p><code>\(
\begin{pmatrix}
7.93e-07 &amp; 2.28e-06 &amp; \cdots &amp; 2.28e-06 &amp; 7.93e-07 \\
2.28e-06 &amp; 6.55e-06 &amp; \cdots &amp; 6.55e-06 &amp; 2.28e-06 \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
2.28e-06 &amp; 6.55e-06 &amp; \cdots &amp; 6.55e-06 &amp; 2.28e-06 \\
7.93e-07 &amp; 2.28e-06 &amp; \cdots &amp; 2.28e-06 &amp; 7.93e-07
\end{pmatrix}
\)</code></p>

<p>Instead, what you&#39;ll usually see is the matrix normalized to [0, 255] and
represented as an image:</p>

<p><img src="/img/gauss_kernel.png" alt=""></p>

<p>We&#39;ll switch to this notation.</p>

<p>Here is the idea in Processing. Sample the Gaussian function, and pass it to our
<code>convolve()</code> method.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="cm">/**</span>
<span class="cm"> * Blurs image with a Gaussian kernel</span>
<span class="cm"> */</span>
<span class="kt">float</span><span class="o">[][]</span> <span class="nf">gaussianBlur</span><span class="o">(</span><span class="kt">float</span><span class="o">[][]</span> <span class="n">img</span><span class="o">,</span> <span class="kt">float</span> <span class="n">sigma</span><span class="o">)</span> <span class="o">{</span>

  <span class="c1">// Generate a 21x21 kernel by sampling the Gaussian function</span>
  <span class="kt">float</span><span class="o">[][]</span> <span class="n">kernel</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="o">[</span><span class="mi">21</span><span class="o">][</span><span class="mi">21</span><span class="o">];</span>
  <span class="kt">int</span> <span class="n">uc</span><span class="o">,</span> <span class="n">vc</span><span class="o">;</span>
  <span class="kt">float</span> <span class="n">g</span><span class="o">,</span> <span class="n">sum</span><span class="o">;</span>
  <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">u</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">kernel</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">u</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">v</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">kernel</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span> <span class="o">{</span>
      <span class="c1">// Center the Gaussian sample so max is at u,v = 10,10</span>
      <span class="n">uc</span> <span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="o">(</span><span class="n">kernel</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
      <span class="n">vc</span> <span class="o">=</span> <span class="n">v</span> <span class="o">-</span> <span class="o">(</span><span class="n">kernel</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">)/</span><span class="mi">2</span><span class="o">;</span>
      <span class="c1">// Calculate and save</span>
      <span class="n">g</span> <span class="o">=</span> <span class="n">exp</span><span class="o">(-(</span><span class="n">uc</span><span class="o">*</span><span class="n">uc</span><span class="o">+</span><span class="n">vc</span><span class="o">*</span><span class="n">vc</span><span class="o">)/(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="o">*</span><span class="n">sigma</span><span class="o">));</span>
      <span class="n">sum</span> <span class="o">+=</span> <span class="n">g</span><span class="o">;</span>
      <span class="n">kernel</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">v</span><span class="o">]</span> <span class="o">=</span> <span class="n">g</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="c1">// Normalize it</span>
  <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">u</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">u</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">kernel</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">u</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">v</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">kernel</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">v</span><span class="o">++)</span> <span class="o">{</span>
      <span class="n">kernel</span><span class="o">[</span><span class="n">u</span><span class="o">][</span><span class="n">v</span><span class="o">]</span> <span class="o">/=</span> <span class="n">sum</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// Convolve and return</span>
  <span class="k">return</span> <span class="nf">convolve</span><span class="o">(</span><span class="n">img</span><span class="o">,</span> <span class="n">kernel</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>And, by allowing the user to control the sigma parameter, we can control how much
the kernel blurs. Below is the image convolved with <code>\(\sigma\)</code> = 0.01, 1.0,
5.0, and 10.0.</p>

<p><img src="/img/blurred_rooms.png" alt=""></p>

<p>That&#39;s basically it, but there are some little tweaks we could add. First, notice
how the Gaussian naturally tapers out; we can exploit this to functionalize the
kernel size based on the inputted sigma value. This can be done analytically (ie.
if you want the cutoff to be no more than 0.5%, then your kernel size needs to be
greater than <code>\(1+2\sqrt{-2 \sigma^2 \ln{0.005}}\)</code>).</p>

<p>With that kind of logic, large sigma values make bigger kernels, which result
in more blurring. Here is <code>\(\sigma = 10\)</code> again, but with a generated kernel
size of 69.</p>

<p><img src="/img/gauss_room.png" alt=""></p>

<p>To be honest, I just wanted to run the picture through my 3D-izer. You have to
admit that looks cool.</p>

<p>Additionally, the Gaussian function is symmetric, so you can separate the 2D
convolution into two 1D convolutions. This provides a speed boost, although I
honestly don&#39;t think that speed is an issue here.</p>

<p>In the <a href="/fourier-frequency-analysis-image-processing-for-scientists-and-engineers-part-5/">next section</a>,
we will go through using convolution and Fourier transforms to find underlying
patterns in images.</p>

</div>

<!-- Disqus comments -->
<script type="text/javascript">
  var disqus_shortname = 'patrickfuller';
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

<!-- MathJax LaTeX editor, with edits from http://stackoverflow.com/questions/10987992/using-mathjax-with-jekyll -->
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  });
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>


          <div id="disqus_thread"></div>

          <div class="footer">
            <div class="contact">
              <p>
                <a href="mailto:patrickfuller@gmail.com"><i class="fa fa-envelope"></i></a>
                <a href="https://github.com/patrickfuller"><i class="fa fa-github"></i></a>
              </p>
            </div>
          </div>
        </div>

    <!-- Javascript -->
    <script src="/js/jquery-1.10.2.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
  </body>
</html>
