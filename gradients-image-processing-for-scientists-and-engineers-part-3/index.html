<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Gradients - Image processing for scientists and engineers, Part 3</title>
        <meta name="viewport" content="width=device-width">

        <!-- CSS - font, bootstrap, syntax, custom -->
        <link href='http://fonts.googleapis.com/css?family=Lato' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="/css/bootstrap.css">
        <link rel="stylesheet" href="/css/font-awesome.min.css">
        <link rel="stylesheet" href="/css/syntax.css">
        <link rel="stylesheet" href="/css/main.css">

    </head>
    <body>

        <div class="site">
          <div class="header">
            <h1 class="title"><a href="/">patrick fuller's blog</a></h1>
            <a class="extra" href="/">home</a>
          </div>

          <h2>Gradients - Image processing for scientists and engineers, Part 3</h2>
<p class="meta">25 Nov 2012</p>

<div class="post">
<p>In the <a href="/convolution-an-introduction-to-image-processing-for-scientists-and-engineers/">previous section</a>,
we discussed the idea of image convolution, which
allows us to gather information on groups of pixels. What can we do with this?
Well, a lot. Let&#39;s start simple.</p>

<p>Remembering that images are data, we can start thinking about slopes. The data
has two dimensions, <code>\(x\)</code> and <code>\(y\)</code>, so it has two gradients,
<code>\(\Delta f / \Delta x\)</code> and <code>\(\Delta f / \Delta y\)</code>. Seeing how
<code>\(\Delta f\)</code> is just <code>\(f_2 - f_1\)</code>, you could design a 3x3 kernel to get
your slopes like so:</p>

<p><code>\(
g_x = \left( \begin{array}{ccc}
0 &amp; 0 &amp; 0\\
0 &amp; -1 &amp; 1\\
0 &amp; 0 &amp; 0
\end{array} \right)\qquad
g_y = \left( \begin{array}{ccc}
0 &amp; 0 &amp; 0\\
0 &amp; -1 &amp; 0\\
0 &amp; 1 &amp; 0
\end{array} \right)
\)</code></p>

<p>Here, we&#39;re ignoring most of the neighbors by setting their weights to zero. The
remaining weights simplify out to a difference of pixels. This is functional, but
as I said in Part 1, images are a <strong>lot</strong> of data. We have pixels to spare. Enter
the <em>Sobel operator</em>, which extends the above definition to use more of the
neighbor pixels.</p>

<p><code>\(
g_x = \left( \begin{array}{ccc}
-1 &amp; 0 &amp; 1\\
-2 &amp; 0 &amp; 2\\
-1 &amp; 0 &amp; 1
\end{array} \right)\qquad
g_y = \left( \begin{array}{ccc}
-1 &amp; -2 &amp; -1\\
0 &amp; 0 &amp; 0\\
1 &amp; 2 &amp; 1
\end{array} \right)
\)</code></p>

<p>The idea is the same here, but now the slope estimates are a little more resistant
to noisy data messing things up.</p>

<p>Not to be outdone (or not to miss out on easy publications), others have jumped
on the make-up-a-gradient-kernel bandwagon. Chief among these is the <em>Scharr operator</em>,
which purports to be a better approximation of derivatives that don&#39;t fall nicely
on the <code>\(x\)</code> or <code>\(y\)</code> axis.</p>

<p><code>\(
g_x = \left( \begin{array}{ccc}
-3 &amp; 0 &amp; 3\\
-10 &amp; 0 &amp; 10\\
-3 &amp; 0 &amp; 3
\end{array} \right)\qquad
g_y = \left( \begin{array}{ccc}
-3 &amp; -10 &amp; -3\\
0 &amp; 0 &amp; 0\\
3 &amp; 10 &amp; 3
\end{array} \right)
\)</code></p>

<p>We can convert the <code>\(x\)</code> and <code>\(y\)</code> derivative approximations to polar
coordinates with <code>\(r = \sqrt{x^2 + y^2}\)</code> and <code>\(\theta = \arctan{y / x}\)</code>.
By representing <code>\(\theta\)</code> as color, the magnitude-and-direction view of 2D
gradients allows us to show the output of gradient convolution on a single image.
It would be messy to edit our old <code>toImage</code> function to do this, so let&#39;s make a
new <code>showDerivative</code> method.</p>
<div class="highlight"><pre><code class="java language-java" data-lang="java"><span class="cm">/**</span>
<span class="cm"> * Creates an image showing gradient as mag, direction</span>
<span class="cm"> */</span>
<span class="n">PImage</span> <span class="nf">showDerivative</span><span class="o">(</span><span class="kt">float</span><span class="o">[][]</span> <span class="n">img</span><span class="o">,</span> <span class="n">String</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
   <span class="kt">float</span><span class="o">[][]</span> <span class="n">dx</span><span class="o">,</span> <span class="n">dy</span><span class="o">,</span> <span class="n">magnitude</span><span class="o">,</span> <span class="n">direction</span><span class="o">;</span>
   <span class="kt">float</span> <span class="n">maximum</span><span class="o">,</span> <span class="n">minimum</span><span class="o">;</span>
   <span class="kt">int</span> <span class="n">luminosity</span><span class="o">;</span>
   <span class="n">color</span> <span class="n">col</span><span class="o">;</span>

   <span class="c1">// Get directional derivatives</span>
   <span class="k">if</span><span class="o">(</span><span class="n">type</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&quot;Scharr&quot;</span><span class="o">))</span> <span class="o">{</span>
     <span class="n">dx</span> <span class="o">=</span> <span class="n">scharrXGradient</span><span class="o">(</span><span class="n">img</span><span class="o">);</span>
     <span class="n">dy</span> <span class="o">=</span> <span class="n">scharrYGradient</span><span class="o">(</span><span class="n">img</span><span class="o">);</span>
   <span class="o">}</span>
   <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">type</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">&quot;Sobel&quot;</span><span class="o">))</span> <span class="o">{</span>
     <span class="n">dx</span> <span class="o">=</span> <span class="n">sobelXGradient</span><span class="o">(</span><span class="n">img</span><span class="o">);</span>
     <span class="n">dy</span> <span class="o">=</span> <span class="n">sobelYGradient</span><span class="o">(</span><span class="n">img</span><span class="o">);</span>
   <span class="o">}</span>
   <span class="k">else</span> <span class="o">{</span>
     <span class="n">dx</span> <span class="o">=</span> <span class="n">xGradient</span><span class="o">(</span><span class="n">img</span><span class="o">);</span>
     <span class="n">dy</span> <span class="o">=</span> <span class="n">yGradient</span><span class="o">(</span><span class="n">img</span><span class="o">);</span>
   <span class="o">}</span>
   <span class="c1">// Convert to radial notation</span>
   <span class="n">magnitude</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="o">[</span><span class="n">img</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">img</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">];</span>
   <span class="n">direction</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">float</span><span class="o">[</span><span class="n">img</span><span class="o">.</span><span class="na">length</span><span class="o">][</span><span class="n">img</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">];</span>
   <span class="n">maximum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">minimum</span> <span class="o">=</span> <span class="n">Float</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
   <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">x</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">img</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">x</span><span class="o">++)</span> <span class="o">{</span>
     <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">y</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">img</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="n">y</span><span class="o">++)</span> <span class="o">{</span>
       <span class="n">magnitude</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="o">(</span><span class="n">pow</span><span class="o">(</span><span class="n">dx</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">],</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="n">pow</span><span class="o">(</span><span class="n">dy</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">],</span> <span class="mi">2</span><span class="o">));</span>
       <span class="n">maximum</span> <span class="o">=</span> <span class="n">max</span><span class="o">(</span><span class="n">maximum</span><span class="o">,</span> <span class="n">magnitude</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]);</span>
       <span class="n">minimum</span> <span class="o">=</span> <span class="n">min</span><span class="o">(</span><span class="n">minimum</span><span class="o">,</span> <span class="n">magnitude</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]);</span>
       <span class="c1">// Direction is in the range [-pi/2, pi/2]</span>
       <span class="n">direction</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="n">atan</span><span class="o">(</span><span class="n">dy</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]/</span><span class="n">dx</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]);</span>
     <span class="o">}</span>
   <span class="o">}</span>

   <span class="n">PImage</span> <span class="n">output</span> <span class="o">=</span> <span class="n">createImage</span><span class="o">(</span><span class="n">img</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">img</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">,</span> <span class="n">RGB</span><span class="o">);</span>
   <span class="n">output</span><span class="o">.</span><span class="na">loadPixels</span><span class="o">();</span>
   <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">x</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">output</span><span class="o">.</span><span class="na">width</span><span class="o">;</span> <span class="n">x</span><span class="o">++)</span> <span class="o">{</span>
     <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">y</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">output</span><span class="o">.</span><span class="na">height</span><span class="o">;</span> <span class="n">y</span><span class="o">++)</span> <span class="o">{</span>
       <span class="n">luminosity</span> <span class="o">=</span> <span class="kt">int</span><span class="o">(</span><span class="mf">255.0</span> <span class="o">*</span> <span class="o">(</span><span class="n">magnitude</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]-</span><span class="n">minimum</span><span class="o">)</span> <span class="o">/</span> <span class="o">(</span><span class="n">maximum</span><span class="o">-</span><span class="n">minimum</span><span class="o">));</span>

       <span class="c1">// Map gradient direction to one of four colors</span>
       <span class="k">if</span><span class="o">(</span><span class="n">direction</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;=</span> <span class="o">-</span><span class="n">PI</span><span class="o">/</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">direction</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="o">-</span><span class="n">PI</span><span class="o">/</span><span class="mi">4</span><span class="o">)</span>
         <span class="n">col</span> <span class="o">=</span> <span class="n">color</span><span class="o">(</span><span class="n">luminosity</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
       <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">direction</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;=</span> <span class="o">-</span><span class="n">PI</span><span class="o">/</span><span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">direction</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="mi">0</span><span class="o">)</span>
         <span class="n">col</span> <span class="o">=</span> <span class="n">color</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">luminosity</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
       <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">direction</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&amp;</span><span class="n">gt</span><span class="o">;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">direction</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">PI</span><span class="o">/</span><span class="mi">4</span><span class="o">)</span>
         <span class="n">col</span> <span class="o">=</span> <span class="n">color</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">luminosity</span><span class="o">);</span>
       <span class="k">else</span>
         <span class="n">col</span> <span class="o">=</span> <span class="n">color</span><span class="o">(</span><span class="n">luminosity</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">luminosity</span><span class="o">);</span>

       <span class="n">output</span><span class="o">.</span><span class="na">pixels</span><span class="o">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">output</span><span class="o">.</span><span class="na">width</span><span class="o">]</span> <span class="o">=</span> <span class="n">col</span><span class="o">;</span>
     <span class="o">}</span>
   <span class="o">}</span>
   <span class="n">output</span><span class="o">.</span><span class="na">updatePixels</span><span class="o">();</span>
   <span class="k">return</span> <span class="n">output</span><span class="o">;</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * Estimates df/dx lazily</span>
<span class="cm"> */</span>
<span class="kt">float</span><span class="o">[][]</span> <span class="nf">xGradient</span><span class="o">(</span><span class="kt">float</span><span class="o">[][]</span> <span class="n">img</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">float</span><span class="o">[][]</span> <span class="n">gx</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mf">0.0</span><span class="o">,</span>  <span class="mf">0.0</span><span class="o">,</span> <span class="mf">0.0</span> <span class="o">},</span>
                   <span class="o">{</span> <span class="mf">0.0</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">1.0</span> <span class="o">},</span>
                   <span class="o">{</span> <span class="mf">0.0</span><span class="o">,</span>  <span class="mf">0.0</span><span class="o">,</span> <span class="mf">0.0</span> <span class="o">}</span> <span class="o">};</span>
  <span class="k">return</span> <span class="nf">convolve</span><span class="o">(</span><span class="n">img</span><span class="o">,</span> <span class="n">gx</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> *  Estimates df/dy lazily</span>
<span class="cm"> */</span>
<span class="kt">float</span><span class="o">[][]</span> <span class="nf">yGradient</span><span class="o">(</span><span class="kt">float</span><span class="o">[][]</span> <span class="n">img</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">float</span><span class="o">[][]</span> <span class="n">gy</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="mf">0.0</span><span class="o">,</span>  <span class="mf">0.0</span><span class="o">,</span> <span class="mf">0.0</span> <span class="o">},</span>
                   <span class="o">{</span> <span class="mf">0.0</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">0.0</span> <span class="o">},</span>
                   <span class="o">{</span> <span class="mf">0.0</span><span class="o">,</span>  <span class="mf">1.0</span><span class="o">,</span> <span class="mf">0.0</span> <span class="o">}</span> <span class="o">};</span>
  <span class="k">return</span> <span class="nf">convolve</span><span class="o">(</span><span class="n">img</span><span class="o">,</span> <span class="n">gy</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * Estimates df/dx using Sobel kernel</span>
<span class="cm"> */</span>
<span class="kt">float</span><span class="o">[][]</span> <span class="nf">sobelXGradient</span><span class="o">(</span><span class="kt">float</span><span class="o">[][]</span> <span class="n">img</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">float</span><span class="o">[][]</span> <span class="n">gx</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">,</span> <span class="mf">1.0</span> <span class="o">},</span>
                   <span class="o">{</span> <span class="o">-</span><span class="mf">2.0</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">,</span> <span class="mf">2.0</span> <span class="o">},</span>
                   <span class="o">{</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">,</span> <span class="mf">1.0</span> <span class="o">}</span> <span class="o">};</span>
  <span class="k">return</span> <span class="nf">convolve</span><span class="o">(</span><span class="n">img</span><span class="o">,</span> <span class="n">gx</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> *  Estimates df/dy using Sobel kernel</span>
<span class="cm"> */</span>
<span class="kt">float</span><span class="o">[][]</span> <span class="nf">sobelYGradient</span><span class="o">(</span><span class="kt">float</span><span class="o">[][]</span> <span class="n">img</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">float</span><span class="o">[][]</span> <span class="n">gy</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">,</span> <span class="o">-</span><span class="mf">2.0</span><span class="o">,</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">},</span>
                   <span class="o">{</span>  <span class="mf">0.0</span><span class="o">,</span>  <span class="mf">0.0</span><span class="o">,</span>  <span class="mf">0.0</span> <span class="o">},</span>
                   <span class="o">{</span>  <span class="mf">1.0</span><span class="o">,</span>  <span class="mf">2.0</span><span class="o">,</span>  <span class="mf">1.0</span> <span class="o">}</span> <span class="o">};</span>
  <span class="k">return</span> <span class="nf">convolve</span><span class="o">(</span><span class="n">img</span><span class="o">,</span> <span class="n">gy</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> * Estimates df/dx using Scharr kernel</span>
<span class="cm"> */</span>
<span class="kt">float</span><span class="o">[][]</span> <span class="nf">scharrXGradient</span><span class="o">(</span><span class="kt">float</span><span class="o">[][]</span> <span class="n">img</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">float</span><span class="o">[][]</span> <span class="n">gx</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="o">-</span><span class="mf">3.0</span><span class="o">,</span>  <span class="mf">0.0</span><span class="o">,</span> <span class="mf">3.0</span> <span class="o">},</span>
                   <span class="o">{</span> <span class="o">-</span><span class="mf">10.0</span><span class="o">,</span> <span class="mf">0.0</span><span class="o">,</span> <span class="mf">10.0</span> <span class="o">},</span>
                   <span class="o">{</span> <span class="o">-</span><span class="mf">3.0</span><span class="o">,</span>  <span class="mf">0.0</span><span class="o">,</span> <span class="mf">3.0</span> <span class="o">}</span> <span class="o">};</span>
  <span class="k">return</span> <span class="nf">convolve</span><span class="o">(</span><span class="n">img</span><span class="o">,</span> <span class="n">gx</span><span class="o">);</span>
<span class="o">}</span>

<span class="cm">/**</span>
<span class="cm"> *  Estimates df/dy using Scharr kernel</span>
<span class="cm"> */</span>
<span class="kt">float</span><span class="o">[][]</span> <span class="nf">scharrYGradient</span><span class="o">(</span><span class="kt">float</span><span class="o">[][]</span> <span class="n">img</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">float</span><span class="o">[][]</span> <span class="n">gy</span> <span class="o">=</span> <span class="o">{</span> <span class="o">{</span> <span class="o">-</span><span class="mf">3.0</span><span class="o">,</span> <span class="o">-</span><span class="mf">10.0</span><span class="o">,</span> <span class="o">-</span><span class="mf">3.0</span> <span class="o">},</span>
                   <span class="o">{</span>  <span class="mf">0.0</span><span class="o">,</span>   <span class="mf">0.0</span><span class="o">,</span>  <span class="mf">0.0</span> <span class="o">},</span>
                   <span class="o">{</span>  <span class="mf">3.0</span><span class="o">,</span>  <span class="mf">10.0</span><span class="o">,</span>  <span class="mf">3.0</span> <span class="o">}</span> <span class="o">};</span>
  <span class="k">return</span> <span class="nf">convolve</span><span class="o">(</span><span class="n">img</span><span class="o">,</span> <span class="n">gy</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>This function can be run with each of the three gradient-approximation kernels.
Below is the unedited image (top left), and then the basic (top right), Sobel
(bottom left), and Scharr (bottom right) kernels.</p>

<p><img src="/img/gradient_rooms.png" alt=""></p>

<p>The basic gradient is the worst of the approximations, but the Sobel and Scharr
aren&#39;t all that different. For this reason, you&#39;ll usually see the Sobel operator
used in literature.</p>

<p>You can probably guess the mathematical representation of this stuff. You&#39;ll
see the image represented as a two-parameter function <code>\(f(x,y)\)</code>, or, more
pompously, the n-dimensional <code>\(f(\textbf{x})\)</code>, where <code>\(\textbf{x}\)</code> is the
generalized vector including <code>\(x\)</code> and <code>\(y\)</code>. The derivatives are then some
combination of <code>\(\delta f / \delta x\)</code>, <code>\(\delta f / \delta y\)</code>,
<code>\(\delta f / \delta r\)</code>, <code>\(\delta f / \delta \theta\)</code>, and
<code>\(\delta f / \delta \textbf{x}\)</code>. Either way, a lot of partial derivatives.
Remember that it&#39;s all just a bunch of people guessing at how to calculate
slopes, and you&#39;ll be fine.</p>

<p>In the <a href="/gaussian-blur-image-processing-for-scientists-and-engineers-part-4/">next section</a>,
we will generalize convolution to include larger groups of pixels and improve
our smoothing function from Part 2.</p>

</div>

<!-- Disqus comments -->
<script type="text/javascript">
  var disqus_shortname = 'patrickfuller';
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

<!-- MathJax LaTeX editor, with edits from http://stackoverflow.com/questions/10987992/using-mathjax-with-jekyll -->
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  });
  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>


          <div id="disqus_thread"></div>

          <div class="footer">
            <div class="contact">
              <p>
                <a href="mailto:patrickfuller@gmail.com"><i class="fa fa-envelope"></i></a>
                <a href="https://github.com/patrickfuller"><i class="fa fa-github"></i></a>
              </p>
            </div>
          </div>
        </div>

    <!-- Javascript -->
    <script src="/js/jquery-1.10.2.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
  </body>
</html>
